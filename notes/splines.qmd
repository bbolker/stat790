---
title: "Splines and basis expansion (week 3?)"
reference-location: margin
citation-location: margin
bibliography: ../stat790.bib
date: today
date-format: "D MMM YYYY"
---

\newcommand{\A}{\mathbf A}
\newcommand{\B}{\mathbf B}
\newcommand{\D}{\mathbf D}
\newcommand{\GGamma}{\boldsymbol \Gamma}
\newcommand{\G}{\mathbf G}
\newcommand{\HH}{\mathbf H}
\newcommand{\I}{\mathbf I}
\newcommand{\N}{\mathbf N}
\newcommand{\Q}{\mathbf Q}
\newcommand{\R}{\mathbf R}
\newcommand{\U}{\mathbf U}
\newcommand{\V}{\mathbf V}
\newcommand{\W}{\mathbf W}
\newcommand{\X}{\mathbf X}
\newcommand{\Y}{\mathbf Y}
\newcommand{\Z}{\mathbf Z}
\newcommand{\bbeta}{\boldsymbol \beta}
\newcommand{\bzero}{\boldsymbol 0}
\newcommand{\eeta}{\boldsymbol \eta}
\newcommand{\OOmega}{\boldsymbol \Omega}
\newcommand{\hatmat}{\mathbf H}
\newcommand{\grad}{\mathbf g}
\newcommand{\p}{\mathbf p}
\newcommand{\uu}{\mathbf u}
\newcommand{\x}{\mathbf x}
\newcommand{\y}{\mathbf y}
\newcommand{\z}{\mathbf z}
\newcommand{\kron}{\bigotimes}

<!-- typically renders in docs/ dir  -->

## linear basis expansion

* transformations of various kinds 
* quadratic expansion
* nonlinear transformations
* indicator variables

Select or regularize from the expanded set.

## polynomial basis

* polynomial basis: $y_i = \sum_{j=0}^n \beta_j x_i^j$

```{r}
## replicate figure 3.2 from Wood
library(ggplot2)
x <- seq(0, 1, length = 101)
n <- 4
y <- sapply(0:n, \(j) x^j)
beta <- c(4.31, -10.72, 16.8, 2.22, -10.88)
y <- cbind(y, fx = y %*% beta)
dimnames(y) <- list(x = x, j = c(0:n, "f(x)"))
yy <- as.data.frame(as.table(y))
yy$x <- as.numeric(as.character(yy$x))
ggplot(yy, aes(x, Freq)) + geom_line() + facet_wrap(~j, scale = "free")
```

## piecewise polynomial bases

* constant, linear, continuous
* basis functions
* translate from $x_i$ to columns of $\X$

## splines

* **piecewise** polynomials with continuity/smoothness constraints
* very useful for function approximation
* convert a single numeric predictor into a flexible basis
* efficient
* with multiple predictors, consider **additive models**
* handle interactions (multidim smooth surfaces) *if reasonably low-dimensional*: tensor products etc.

## spline terminology

* **knots**: breakpoints (boundary, interior)
* order-M (ESL): continuous derivatives up to order $M-2$ (cubic, $M=4$)
* typically $M=1$, 2, 4
* number of knots = df (degrees of freedom) -1 -intercept

## truncated power basis

* $X^0 \ldots X^{n}$
* remaining columns are $(x-\xi_\ell)+^{M-1}$ where $\ell$ are the *interior knots*

## truncated power basis

* **Kronecker product**: blockwise multiplication ($\A \kron \B$ multiplies $\B$ by each $a_[ij}$)
* **Khatri-Rao product**: columnwise Kronecker product
   * super-handy for combining indicator variables with 


```{r echo=FALSE}
truncpolyspline <- function(x, df) {
    if (!require("Matrix")) stop("need Matrix package")
    knots <- quantile(x, seq(0, 1, length = df - 1))
    ## should probably use seq() instead of `:`
    ## dim: n x (df-2)
    X <- Matrix(sapply(knots[1:(df-2)], \(k) (x>k)*(x-k)))
    ## dim: n x 1
    J <- matrix(x^3, ncol = 1)
    ## dim: n x (df-2)
    S <- t(KhatriRao(t(X), t(J)))
    ## dim: n x df
    S <- cbind(x, x^2, S)
    return(S)
}
xvec <- seq(0, 1, length = 101)
tS <- truncpolyspline(xvec, df = 7)
image(tS, aspect = "fill")
matplot(scale(tS), type = "l")
```

```{r truncpoly}
set.seed(101)
beta <- rnorm(8)
plot(xvec, cbind(1, tS) %*% beta)
```

## B-spline basis

* splines of a given order with *minimal support* (i.e., local)
* basis functions defined by recursion (not pretty)
* convenient for regression splines (see below)

## natural cubic splines

* linear constraints beyond boundary knots (so 2d and 3d derivatives are 0 at the boundaries)

```{r}
library(splines)
bb <- bs(1:20, df = 5)
attributes(bb)[c("degree", "knots", "Boundary.knots")]
nn <- ns(1:20, df = 7)
attributes(nn)[c("degree", "knots", "Boundary.knots")]
```

```{r fig.width = 8}
par(mfrow = c(1,2),las =1, bty ="l")
matplot(ns(1:20, df = 5), type = "l", main = "natural spline")
matplot(bs(1:20, df = 5), type = "l", main = "B-spline")
```

## sparsity patterns

```{r}
library(Matrix)
dd <- data.frame(x=1:200)
Xb <- model.matrix(~splines::bs(x, df = 10), data = dd)
Xn <- model.matrix(~splines::ns(x, df = 10), data = dd)
gridExtra::grid.arrange(
               ncol = 2,
               image(Matrix(Xb), aspect = "fill"),
               image(Matrix(Xn), aspect = "fill")
               )
```

## smoothing splines

* as many knots as data points
* plus squared-second-derivative ("wiggliness") penalty

$$
\textrm{RSS} + \lambda \int (f''(t))^2 \, dt
$$
* defined on an infinite-dimensional space
* minimizer is a natural cubic spline with knots at $x_i$

$$
(\y - \N  \theta)^\top (\y - \N \theta) + \lambda \theta^\top \OOmega_N \theta
$$
with $\{\OOmega_N\}_{jk} = \int N_j''(t) N_k''(t) \, dt$
$$
**generalized** ridge regression: penalize by $\lambda \OOmega_N$ rather than $\lambda I$
* same data augmentation methods as before except that now we use $\sqrt{\lambda} C$ where $C$ is a matrix
square root of $\OOmega_N$

See @woodGeneralized2017, @perperogloureview2019a

## examples: South African heart disease

* use splines in a GLM with no additional effort
* fit splines to all continuous variables
* ESL says "use four natural spline bases" (... elements??)
* i.e. `df = 4` (no intercept)
* stepwise deletion via AIC
* why??
* showing p-values (why???)
* `stepAIC(..., direction = "backward")`

## example

## degrees of freedom and smoother matrix

- The equivalent of the hat matrix is 



## multidimensional splines

## tensor produce

## thin-plate splines

## null space

## reduced-rank

