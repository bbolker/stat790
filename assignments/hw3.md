## hw 3 (due 3 March, midnight)

* Replicate a figure from ESL chapter 5
* Using the South Africa coronary heart disease data (see [code file](../code/southafrica.R)); construct b-spline, natural spline, and truncated polynomial spline bases (all with 6 knots: you can use the `splines` package or equivalents, you don't have to do this part "from scratch"). Fit a logistic regression using each of these bases. Compute the predicted value and the predicted variance for the *linear predictor* (i.e. on the log-odds scale), without using the built-in `predict(..., se.fit = TRUE)` methods.  Plot the predictions Â± 1 SE for each of the three bases.
* Write a function (in R/Julia/Python/whatever), starting from the truncated polynomial basis function presented in the notes (or write your own), that adds a natural spline constraint by using the constraint equations described [here](https://stats.stackexchange.com/questions/172217/why-are-the-basis-functions-for-natural-cubic-splines-expressed-as-they-are-es). In addition to the `x`, `df` arguments your function should take a `natural` argument that is true or false (`TRUE` or `FALSE` in R) to decide whether to impose the constraint. Plot an example of regular and natural bases side-by-side (e.g. using `matplot()` as in the notes).
*  a. Write a function to simulate data drawn from a smooth two-dimensional surface on the unit square with Gaussian noise. You could use (for example) a reasonably high-order bivariate polynomial, or a kernel function/mixture model (i.e. $f(x,y) = \sum_j w_j \exp(((x-x_j)^2 + (y-y_j)^2)/s_j^2)$), or using a 2D spline.
b. Use `mgcv::gam()` to fit two-dimensional splines to your simulated data, using `z ~ te(gp, x, y)`. Over an ensemble of 250 simulations, compute the average computation time, bias, variance, and mean-squared error of your predictions for (i) `method = "GCV.Cp"` (generalized cross-validation) and (ii) `method = "REML"` (restricted maximum likelihood).
* ESL exercises: 5.4, 5.13
